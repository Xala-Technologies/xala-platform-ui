/**
 * Platform UI Interactive Installer
 *
 * CLI tool that intelligently sets up Platform UI in a project:
 * 1. Detects app framework (Vite, Next.js, CRA, etc.)
 * 2. Asks for theme preference
 * 3. Modifies main.tsx to add required providers
 * 4. Sets up ESLint configuration
 * 5. Adds compliance tests
 * 6. Validates the setup
 *
 * @example
 * ```bash
 * guardrails install
 * guardrails install --theme=digilist --skip-prompts
 * ```
 */

import { existsSync, readFileSync, writeFileSync, mkdirSync } from 'fs';
import { join, dirname } from 'path';

// ============================================================================
// Types
// ============================================================================

export interface InstallOptions {
  /** Project root directory */
  projectDir: string;
  /** Theme to use (prompts if not provided) */
  theme?: ThemeId;
  /** Skip interactive prompts */
  skipPrompts?: boolean;
  /** Dry run - don't actually modify files */
  dryRun?: boolean;
  /** Verbose output */
  verbose?: boolean;
}

export type ThemeId = 'digdir' | 'altinn' | 'brreg' | 'digilist' | 'xaheen' | 'platform';

export interface DetectedFramework {
  name: 'vite' | 'nextjs' | 'cra' | 'unknown';
  entryFile: string | null;
  configFile: string | null;
}

export interface InstallResult {
  success: boolean;
  filesModified: string[];
  filesCreated: string[];
  errors: string[];
  warnings: string[];
}

// ============================================================================
// Framework Detection
// ============================================================================

export function detectFramework(projectDir: string): DetectedFramework {
  // Check for Vite
  const viteConfig = ['vite.config.ts', 'vite.config.js', 'vite.config.mjs']
    .map((f) => join(projectDir, f))
    .find((f) => existsSync(f));

  if (viteConfig) {
    const mainEntries = ['src/main.tsx', 'src/main.ts', 'src/index.tsx', 'src/index.ts'].map((f) =>
      join(projectDir, f)
    );

    const entryFile = mainEntries.find((f) => existsSync(f));

    return {
      name: 'vite',
      entryFile: entryFile || null,
      configFile: viteConfig,
    };
  }

  // Check for Next.js
  const nextConfig = ['next.config.ts', 'next.config.js', 'next.config.mjs']
    .map((f) => join(projectDir, f))
    .find((f) => existsSync(f));

  if (nextConfig) {
    const appEntries = [
      'src/app/layout.tsx',
      'app/layout.tsx',
      'src/pages/_app.tsx',
      'pages/_app.tsx',
    ].map((f) => join(projectDir, f));

    const entryFile = appEntries.find((f) => existsSync(f));

    return {
      name: 'nextjs',
      entryFile: entryFile || null,
      configFile: nextConfig,
    };
  }

  // Check for Create React App
  const craMarker = join(projectDir, 'node_modules', 'react-scripts');
  if (existsSync(craMarker)) {
    const entryFile = existsSync(join(projectDir, 'src/index.tsx'))
      ? join(projectDir, 'src/index.tsx')
      : existsSync(join(projectDir, 'src/index.js'))
        ? join(projectDir, 'src/index.js')
        : null;

    return {
      name: 'cra',
      entryFile,
      configFile: null,
    };
  }

  return {
    name: 'unknown',
    entryFile: null,
    configFile: null,
  };
}

// ============================================================================
// Provider Injection
// ============================================================================

/**
 * Generate the provider wrapper code for main.tsx
 */
export function generateProviderCode(theme: ThemeId): string {
  return `/**
 * Platform UI Providers
 *
 * This file sets up the required providers for @xala-technologies/platform-ui.
 * Generated by: guardrails install
 *
 * REQUIRED PROVIDERS (in order):
 * 1. GlobalErrorHandler - Catches window errors, promise rejections, chunk load failures
 * 2. ErrorBoundary - Catches React component errors
 * 3. ThemeProvider - Manages light/dark theme
 * 4. DesignsystemetProvider - Provides design system context
 *
 * DO NOT REMOVE these providers - they are required for Platform UI compliance.
 */

import React from 'react';
import ReactDOM from 'react-dom/client';
import {
  GlobalErrorHandler,
  ErrorBoundary,
  ThemeProvider,
  DesignsystemetProvider,
} from '@xala-technologies/platform-ui';
import '@xala-technologies/platform-ui/styles';
import { App } from './App';

// Full height layout
if (typeof document !== 'undefined') {
  const style = document.createElement('style');
  style.textContent = 'html, body, #root { height: 100%; margin: 0; }';
  document.head.appendChild(style);
}

const root = document.getElementById('root');

if (!root) {
  throw new Error('Root element #root not found in document');
}

ReactDOM.createRoot(root).render(
  <React.StrictMode>
    <GlobalErrorHandler
      onError={(error) => {
        console.error('[GlobalErrorHandler]', error.type, error.message);
      }}
    >
      <ErrorBoundary
        onError={(error, errorInfo) => {
          console.error('[ErrorBoundary]', error.message, errorInfo.componentStack);
        }}
      >
        <ThemeProvider>
          <DesignsystemetProvider theme="${theme}" colorScheme="auto" locale="nb">
            <App />
          </DesignsystemetProvider>
        </ThemeProvider>
      </ErrorBoundary>
    </GlobalErrorHandler>
  </React.StrictMode>,
);
`;
}

/**
 * Check if the entry file already has Platform UI providers
 */
export function hasProvidersConfigured(entryContent: string): boolean {
  const requiredPatterns = [
    /GlobalErrorHandler/,
    /ErrorBoundary/,
    /DesignsystemetProvider|ThemeProvider/,
    /@xala-technologies\/platform-ui/,
  ];

  return requiredPatterns.every((pattern) => pattern.test(entryContent));
}

/**
 * Inject providers into existing entry file
 */
export function injectProviders(
  entryContent: string,
  theme: ThemeId
): { content: string; warnings: string[] } {
  const warnings: string[] = [];

  // Check if already configured
  if (hasProvidersConfigured(entryContent)) {
    warnings.push('Provider configuration already detected. Skipping injection.');
    return { content: entryContent, warnings };
  }

  // Add imports at the top
  const importStatement = `import {
  GlobalErrorHandler,
  ErrorBoundary,
  ThemeProvider,
  DesignsystemetProvider,
} from '@xala-technologies/platform-ui';
import '@xala-technologies/platform-ui/styles';
`;

  // Check for existing imports to place our import after
  const importMatch = entryContent.match(/^(import .+\n)+/m);
  let newContent: string;

  if (importMatch) {
    const lastImportEnd = importMatch.index! + importMatch[0].length;
    newContent =
      entryContent.slice(0, lastImportEnd) +
      '\n' +
      importStatement +
      entryContent.slice(lastImportEnd);
  } else {
    newContent = importStatement + '\n' + entryContent;
  }

  // Now we need to wrap the render call
  // This is complex - we'll warn the user to manually verify
  warnings.push(
    'Provider imports have been added. Please manually wrap your App component with the required providers.'
  );
  warnings.push('See: https://github.com/Xala-Technologies/xala-platform-ui#providers');

  return { content: newContent, warnings };
}

// ============================================================================
// ESLint Setup
// ============================================================================

export function generateESLintConfig(): string {
  return `/**
 * ESLint Configuration for Platform UI
 *
 * Generated by: guardrails install
 *
 * This configuration extends Platform UI rules which enforce:
 * - No raw HTML elements (use platform-ui components)
 * - No direct @digdir imports (use platform-ui wrappers)
 * - Design token usage for styling
 *
 * DO NOT REMOVE these rules - they are required for Platform UI compliance.
 */

import { createFlatConfig } from '@xala-technologies/guardrails/eslint';
import tseslint from 'typescript-eslint';
import reactPlugin from 'eslint-plugin-react';
import reactHooksPlugin from 'eslint-plugin-react-hooks';

export default [
  // Platform UI mandatory rules
  ...createFlatConfig(),

  // TypeScript
  ...tseslint.configs.recommended,

  // React
  {
    plugins: {
      react: reactPlugin,
      'react-hooks': reactHooksPlugin,
    },
    rules: {
      'react-hooks/rules-of-hooks': 'error',
      'react-hooks/exhaustive-deps': 'warn',
    },
    settings: {
      react: {
        version: 'detect',
      },
    },
  },

  // i18n enforcement - no hardcoded strings
  {
    rules: {
      // Add jsx-a11y rules for accessibility
      // 'jsx-a11y/alt-text': 'error',
      // 'jsx-a11y/anchor-is-valid': 'error',
    },
  },

  // Your custom rules below
];
`;
}

// ============================================================================
// Compliance Tests Setup
// ============================================================================

export function generateComplianceTest(): string {
  return `/**
 * Platform UI Compliance Tests
 *
 * Generated by: guardrails install
 *
 * These tests ensure your app complies with Platform UI requirements:
 * - No raw HTML elements in source files
 * - No inline styles without design tokens
 * - No direct @digdir imports
 * - Required providers are present
 *
 * Run with: pnpm test:compliance
 *
 * DO NOT DELETE this file - it is required for Platform UI compliance.
 */

import { describe, test, expect } from 'vitest';
import { createViolationTests } from '@xala-technologies/guardrails/testing';
import { checkProviderConfiguration } from '@xala-technologies/guardrails/compliance';

// Standard violation tests
createViolationTests({
  srcDir: './src',
  describe,
  test,
  expect,
});

// Provider configuration test
describe('Platform UI Provider Configuration', () => {
  test('main entry file has required providers', () => {
    const result = checkProviderConfiguration('./src');

    if (!result.passed) {
      console.error('Missing providers:', result.missingProviders);
    }

    expect(result.passed).toBe(true);
  });
});
`;
}

// ============================================================================
// Main Install Function
// ============================================================================

export async function install(options: InstallOptions): Promise<InstallResult> {
  const { projectDir, theme = 'digilist', dryRun = false, verbose = false } = options;

  const result: InstallResult = {
    success: false,
    filesModified: [],
    filesCreated: [],
    errors: [],
    warnings: [],
  };

  const log = (msg: string) => verbose && console.log(msg);

  try {
    // Step 1: Detect framework
    log('Detecting framework...');
    const framework = detectFramework(projectDir);
    log(`Detected: ${framework.name}`);

    if (framework.name === 'unknown') {
      result.warnings.push('Could not detect framework. Assuming Vite.');
    }

    // Step 2: Check package.json
    const packageJsonPath = join(projectDir, 'package.json');
    if (!existsSync(packageJsonPath)) {
      result.errors.push('package.json not found. Are you in a project directory?');
      return result;
    }

    const packageJson = JSON.parse(readFileSync(packageJsonPath, 'utf-8'));

    // Step 3: Check if platform-ui is installed
    const deps = { ...packageJson.dependencies, ...packageJson.devDependencies };
    if (!deps['@xala-technologies/platform-ui']) {
      result.warnings.push(
        '@xala-technologies/platform-ui is not installed. Run: pnpm add @xala-technologies/platform-ui'
      );
    }
    if (!deps['@xala-technologies/guardrails']) {
      result.warnings.push(
        '@xala-technologies/guardrails is not installed. Run: pnpm add -D @xala-technologies/guardrails'
      );
    }

    // Step 4: Create/update entry file
    if (framework.entryFile && existsSync(framework.entryFile)) {
      log(`Found entry file: ${framework.entryFile}`);
      const entryContent = readFileSync(framework.entryFile, 'utf-8');

      if (hasProvidersConfigured(entryContent)) {
        log('Providers already configured.');
        result.warnings.push(
          'Provider configuration already detected. Skipping entry file modification.'
        );
      } else {
        const { content, warnings } = injectProviders(entryContent, theme);
        result.warnings.push(...warnings);

        if (!dryRun) {
          writeFileSync(framework.entryFile, content);
          result.filesModified.push(framework.entryFile);
        } else {
          log(`[DRY RUN] Would modify: ${framework.entryFile}`);
        }
      }
    } else {
      // Create new main.tsx
      const mainPath = join(projectDir, 'src', 'main.tsx');
      const mainDir = dirname(mainPath);

      if (!existsSync(mainDir)) {
        if (!dryRun) {
          mkdirSync(mainDir, { recursive: true });
        }
      }

      if (!dryRun) {
        writeFileSync(mainPath, generateProviderCode(theme));
        result.filesCreated.push(mainPath);
      } else {
        log(`[DRY RUN] Would create: ${mainPath}`);
      }
    }

    // Step 5: Create ESLint config
    const eslintPath = join(projectDir, 'eslint.config.platform-ui.js');
    if (!existsSync(eslintPath)) {
      if (!dryRun) {
        writeFileSync(eslintPath, generateESLintConfig());
        result.filesCreated.push(eslintPath);
      } else {
        log(`[DRY RUN] Would create: ${eslintPath}`);
      }
    } else {
      result.warnings.push('eslint.config.platform-ui.js already exists. Skipping.');
    }

    // Step 6: Create compliance tests
    const testsDir = join(projectDir, 'tests');
    const complianceTestPath = join(testsDir, 'platform-ui-compliance.test.ts');

    if (!existsSync(complianceTestPath)) {
      if (!dryRun) {
        if (!existsSync(testsDir)) {
          mkdirSync(testsDir, { recursive: true });
        }
        writeFileSync(complianceTestPath, generateComplianceTest());
        result.filesCreated.push(complianceTestPath);
      } else {
        log(`[DRY RUN] Would create: ${complianceTestPath}`);
      }
    } else {
      result.warnings.push('Compliance test file already exists. Skipping.');
    }

    // Step 7: Update package.json scripts
    if (!dryRun) {
      const scriptsToAdd: Record<string, string> = {
        'test:compliance': 'vitest run tests/platform-ui-compliance.test.ts',
        'verify:compliance': 'guardrails check-compliance',
        'lint:platform-ui': 'eslint --config eslint.config.platform-ui.js src',
      };

      let scriptsUpdated = false;
      packageJson.scripts = packageJson.scripts || {};

      for (const [key, value] of Object.entries(scriptsToAdd)) {
        if (!packageJson.scripts[key]) {
          packageJson.scripts[key] = value;
          scriptsUpdated = true;
        }
      }

      if (scriptsUpdated) {
        writeFileSync(packageJsonPath, JSON.stringify(packageJson, null, 2) + '\n');
        result.filesModified.push(packageJsonPath);
      }
    }

    result.success = result.errors.length === 0;
    return result;
  } catch (error) {
    result.errors.push(error instanceof Error ? error.message : String(error));
    return result;
  }
}

// ============================================================================
// Exports
// ============================================================================

export default {
  install,
  detectFramework,
  generateProviderCode,
  generateESLintConfig,
  generateComplianceTest,
  hasProvidersConfigured,
  injectProviders,
};
